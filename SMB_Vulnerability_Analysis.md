# Tracing Bugs Across Kernels: SMB Vulnerabilities in macOS and FreeBSD

## Introduction

Security research often focuses on individual systems in isolation. A vulnerability is found, patched, and the case is closed. But operating systems today are complex systems built on shared foundations—often reusing or forking large chunks of code from other platforms. These connections open up an underutilized approach in vulnerability research: **cross-operating system variant analysis**.

In this post, I’ll walk through a vulnerability in macOS’s in-kernel SMB client that led me to a related issue in FreeBSD. The two systems share a common SMB implementation, originally written for FreeBSD and later imported by Apple. By analyzing how code is inherited and reused across platforms, we can uncover bugs that are otherwise easy to overlook.

---

## macOS and FreeBSD: Shared SMB Roots

Both macOS and FreeBSD ship with in-kernel SMB clients. These are used to mount SMB shares (e.g., via `smb://` URLs or `mount_smbfs`) and trace their origins to the early 2000s, when Boris Popov contributed an in-kernel SMB client to FreeBSD’s `sys/netsmb` subsystem. Apple later imported this implementation into macOS, modifying and maintaining it in their own kernel tree.

That shared lineage means assumptions or design flaws in the original FreeBSD code can quietly persist in downstream forks—sometimes for decades.

---

## Vulnerability in `smb_dev2share()`

On macOS, when mounting an SMB share using the `mount` system call, the userland initiates a `mount_smbfs` operation that passes a `struct smb_mount_args` to the kernel. One of the fields in this structure is `args->dev`, which represents the device node created by `nsmb`. The kernel's VFS layer dispatches this to the `smbfs_mount()` function in the SMB file system driver. Inside `smbfs_mount()`, the code retrieves `args->dev` and passes it to `smb_dev2share()`, which uses the minor number of the device to resolve a pointer to an active `smb_share` object.

Inside `smb_dev2share()`, the code retrieves a vnode from the file descriptor, obtains the underlying `dev_t` device using `vn_todev()`, and finally calls `SMB_GETDEV()` to fetch the associated SMB device structure. The relevant snippet looks like this:

```c
error = file_vnode_withvid(fd, &vp, NULL);
if (error) {
    return (error);
}
lck_rw_lock_exclusive(dev_rw_lck);
if (vp) {
    dev = vn_todev(vp);
}
if (dev != NODEV) {
    sdp = SMB_GETDEV(dev);
}
```

This snippet is critical because `SMB_GETDEV(dev)` is defined as:

```c
#define SMB_GETDEV(dev) (smb_dtab[minor(dev)])
```

This macro does **not perform any bounds checking** on the minor device number. It assumes that `minor(dev)` is a valid index into the `smb_dtab[]` array. However, on macOS, the `minor()` macro can return values up to 0xFFFFFF (24 bits). If an attacker can control or forge a device identifier with a large minor number, this leads to an **out-of-bounds array access**.

Because the result of `SMB_GETDEV()` is trusted as a valid pointer, this can cause the kernel to dereference memory outside the intended array. Depending on memory layout and reuse patterns, this could result in type confusion, memory corruption, or even arbitrary kernel code execution.

---

## Chasing the Bug’s Ancestry

After identifying this macOS vulnerability, I wanted to understand why it had persisted and whether it affected other systems sharing the same SMB codebase. Since macOS’s in-kernel SMB client originated from FreeBSD, I turned to the FreeBSD source to see if a similar flaw existed there.

This approach—tracing the lineage of inherited code to hunt for variant vulnerabilities—is powerful. It can reveal systemic issues overlooked by platform-specific audits.

---

## A FreeBSD Variant

FreeBSD follows a similar kernel call chain when mounting an SMB share:  
`mount → smbfs_mount → smb_dev2share`.

While the high-level goal of `smb_dev2share()` is the same on both macOS and FreeBSD—to convert a user-provided file descriptor into an active SMB session—its implementation is different. Instead of using a global device table indexed by minor device numbers like macOS, FreeBSD uses the `devfs_get_cdevpriv()` interface to retrieve device-specific private data.

Here is the relevant FreeBSD `smb_dev2share()` implementation, simplified:

```c
int smb_dev2share(int fd, int mode, struct smb_cred *scred,
                  struct smb_share **sspp, struct smb_dev **ssdp)
{
    struct file *fp, *fptmp;
    struct smb_dev *sdp;
    struct smb_share *ssp;
    struct thread *td;
    int error;

    td = curthread;
    error = fget(td, fd, &cap_read_rights, &fp);
    if (error)
        return error;

    fptmp = td->td_fpop;
    td->td_fpop = fp;
    error = devfs_get_cdevpriv((void **)&sdp);
    td->td_fpop = fptmp;
    fdrop(fp, td);

    if (error || sdp == NULL)
        return error;

    SMB_LOCK();
    *ssdp = sdp;
    ssp = sdp->sd_share;
    if (ssp == NULL) {
        SMB_UNLOCK();
        return ENOTCONN;
    }

    error = smb_share_get(ssp, scred);
    if (error == 0) {
        sdp->refcount++;
        *sspp = ssp;
    }
    SMB_UNLOCK();
    return error;
}
```

This implementation still trusts that the file descriptor refers to a valid `nsmb` device and assumes that `devfs_get_cdevpriv()` will return a pointer to a `struct smb_dev *`. However, it does **not perform type validation** to ensure that the `fd` passed in actually belongs to the SMB device.

If a user passes a file descriptor that refers to an unrelated device—such as a block or character device—`devfs_get_cdevpriv()` may still succeed and return a pointer to a kernel object incompatible with `struct smb_dev *`.

Since the returned pointer is blindly cast and dereferenced, this leads to a **type confusion vulnerability**. Accessing fields like `sdp->sd_share` on an invalid pointer can cause memory corruption, use-after-free, or potential kernel code execution in the right conditions.

Although FreeBSD’s design avoids using unchecked minor numbers as array indices, the same fundamental risky assumption remains: **user-supplied device identifiers are always valid and properly typed.**

---

## Why Variant Analysis Matters

Traditional vulnerability discovery techniques like fuzzing are powerful but have limitations. For the two vulnerabilities discussed here, simple fuzzing alone would likely struggle to find the issues because the exploit conditions are quite specific:

- In the macOS case, the file descriptor must correspond to a device node with an **overly large minor number**—something that normal usage or random fuzzing inputs rarely produce.

- In the FreeBSD case, the file descriptor must refer to a **valid, open device file** that supports `devfs_get_cdevpriv()`, but actually be of the wrong device type, which is a subtle state unlikely to be reached by blind fuzzing.

These constraints mean the vulnerabilities are “hidden” in uncommon or unexpected scenarios that require understanding the kernel’s internal assumptions and device handling semantics.

By contrast, **cross-codebase variant analysis** leverages knowledge of code inheritance and architectural similarities across platforms. This approach helps identify vulnerabilities by tracing how risky assumptions propagate through forks and ports—even if they evade traditional automated discovery.

In other words, variant analysis complements fuzzing and other techniques by targeting the *root causes* of vulnerabilities, especially in shared legacy code.

---

Feel free to reach out if you want to discuss this further or contribute!

---

*End of post*
